__NO_SQL__=1
__NO_OPTIONS__=1
__NO_GUI__=1
__NO_NETWORK__=1

CROSS=arm-elf-
__ARM__=1
export __ARM__
NO_NASM=1

MKCFLAGS+=-D__ARM__ -D_NO_SEMTIMEDOP_ -O9
include $(SACK_BASE)/makefiles/makefile.lnx.config
ifeq '1' '0'
ifndef CONFIG_FILE_INCLUDED
CONFIG_FILE_INCLUDED=1

# option this out on older GCC compilers...
# NO_DEPENDS=1

# if and only if GCC3.0+ is used.
__LINUX__=1
export __LINUX__
#ASM_C_FLAGS=-DHAS_ASSEMBLY
#HAVE_NASM=1

ifdef WORDALIGN
ALIGN=
else
ALIGN=
endif

nullstring :=
space := $(nullstring) # end of the line
# exerpt from make manual (3.79.1) describing the above declaration 
# of $(space) ...
# Here the value of the variable space is precisely one 
# space. The comment `# end of the line' is included 
# here just for clarity. Since trailing space characters 
# are not stripped from variable values, just a space at 
# the end of the line would have the same effect (but be 
# rather hard to read). If you put whitespace at the end 
# of a variable value, it is a good idea to put a comment
# like that at the end of the line to make your intent 
# clear.
SYSPATHCHAR:=/
PATHCHAR=/
OBJEXT=o
LIBEXT=.a
# the extension applied to libraries to link to
LINK_LIBEXT= 
# a prefix command applied to libraries to link to
LIBPREFIX=-l
LIBNAMEPREFIX=lib
SHLIBEXT=.so
PROGEXT=
OUTNAMEOPT=-o
#MAPOUTOPT=-Map$(space)
MAPOUTOPT=-Wl,-Map,
MAKE_DLL_OPT=-shared
LD_OUTNAMEOPT=-o$(space)
LD_BASE_OPTS=-Wl,-warn-common -Wl,-rpath-link,.
USES_RPATH=1
ifdef STATIC
 ifneq '$(FINALDEST)' ''
  LD_DEBUG_FLAGS=$(LD_BASE_OPTS) -g -Wl,-rpath-link,$(FINALDEST)/lib/$(DEST_SUFFIX)
  LD_RELEASE_FLAGS=$(LD_BASE_OPTS) -s -Wl,-rpath-link,$(FINALDEST)/lib/$(DEST_SUFFIX)
 else
  LD_DEBUG_FLAGS=$(LD_BASE_OPTS) -g
  LD_RELEASE_FLAGS=$(LD_BASE_OPTS) -s
 endif
else
 ifneq '$(FINALDEST)' ''
  LD_DEBUG_FLAGS=$(LD_BASE_OPTS) -g -Wl,-rpath-link,$(FINALDEST)/bin/$(DEST_SUFFIX)
  LD_RELEASE_FLAGS=$(LD_BASE_OPTS) -s -Wl,-rpath-link,$(FINALDEST)/bin/$(DEST_SUFFIX)
 else
  LD_DEBUG_FLAGS=$(LD_BASE_OPTS) -g
  LD_RELEASE_FLAGS=$(LD_BASE_OPTS) -s
 endif
endif
# do not define this option if it's not used!
#SUBSYSOPT=
LN_OUTNAMEOPT=
LIBPATHOPT=-L
# this flag should be defined if and only if ppc is used...
# else we'll assume that the native compiler has bad arguments
# or is additionally switched based on the compiler type...
# -DHAVE_GOOD_VA_ARGS 
C_DEPEND_FLAGS=-I/opt/arm/arm-elf/include -MMD -MF $(@:.o=.d)
C_COMMON_FLAGS:=-DEMPTY_STRUCT="struct{}" -DGCC -D__UNIX__ -D__LINUX__ -D__ARM__ $(ASM_C_FLAGS) $(MKCFLAGS)
C_RELEASE_FLAGS=-O3
C_DEBUG_FLAGS=-g -D_DEBUG
#CC=gcc -c $(C_COMMON_FLAGS)
CC=$(CROSS)gcc -c -Wall $(C_$(DEST_TYPE)_FLAGS) $(ALIGN) $(C_COMMON_FLAGS) $(C_DEPEND_FLAGS)
CXX=$(CROSS)g++ -c -Wall $(C_$(DEST_TYPE)_FLAGS) $(ALIGN) $(C_COMMON_FLAGS) $(C_DEPEND_FLAGS)

PPCCPP=$(SACK_BASE)/makefiles/ppc

# this rule should be correct for gcc to compile correctly
# then we just have to worry about c99 incompliancy on Windoze!
# 2.95.3 may or may not compile - but that can be handled with flags...
# or- even better - use the simple CC rule...
#define CCRULE
#        $(CC) $(OUTNAMEOPT)$(2) $(1) -MF$(4) -MT$(2) $(3)
#endef

#define CCRULE
#	$(SACK_BASE)/makefiles/ppc -l $(C_COMMON_FLAGS) $(1) -o$(2:.$(OBJEXT)=.i) -MF$(4) -MT$(2) $(3)
#        $(CC) $(OUTNAMEOPT)$(2) $(2:.$(OBJEXT)=.i)
#endef

define LD_INPUT
$(1)
endef

LD=$(CROSS)gcc $(MKLDFLAGS) $(LD_$(DEST_TYPE)_FLAGS)
LD_DEF_OPT=
SHARED_ONLY=1
AR=ar r
RC=lrc

#AFLAGS=-f elf -i$(SACK_BASE)/include/nasm/ -D__LINUX__ $(STATFLAGS)
#ASM=nasm
ASM=echo 'I got no assembler!'

# depend list on linux is auto built with the executables.
MAKEDEPLIST=
define MAKEDEPEND
endef

endif

endif
