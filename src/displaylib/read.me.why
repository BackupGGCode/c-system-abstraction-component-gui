
Why not just interface with SDL directly instead of this minor layer?

Well - windows native interface cloned from vidlib would be useful.

Vidlib is about to undergo it's destruction/resurrection evolution phase.
You don't get chickens without breaking eggs.

And since SDL is layered mostly on a unix layer... perhaps not since it
has some direct show interface supposedly?

Well... 

There is a place for a single surface which is partitioned for everyone.
This is a display server/library.  A library can call directly and is 
tightly coupled.  A server is distributable, however, this increases a bit
of overhead/slowness in the data transfers as there are more pools/movings
and schedulings that must occur.

Screens - or that which is visible on a display may be active, and may
be built from the entire root of the display.  In this case, one and only
one screen maybe be shown.  This can be handled... either the other screens
may truly exist, and be constructed as their components are updated... or...
these components may exist and only draw when instructed to, and if they
attempt to update to a screen which is not present, will quietly fail.  Though
if this update is important, then they should have a way to query - can anyone
see me?

-------------------------------------------------------------------

So - rip apart vid lib - modify the 'active image' interface.
This should auto layer on linux/SDL and windows.
display object 
	screen objects
   	surface objects 
	   screen objects
	display

display is the framing for all surfaces.
there MAY be more than one display.  This is for an environment like windows
or X where there is capability to have many applications with windows.
Some things (docked windows) may wish to be outside of the main frame.
This cannot be done with SDL.

--------------------------------------------------------------------
careful staging to the physical layer must be maintained.
Very most primitive structure for the application.  Well aliasing this
structure has proven to be most effective requiring recompilation of
peices without impact (nessecarily) on the others.


--------------------------------------------------------------------

Open the display...
Get the display surface and partition it....
Create a popup window.... (with-in with an option with-out?)

--------------------------------------------------------------------

InitDisplay()
CreateScreen( "name" );
SelectScreen( "name" );
LoadScreen( "name" );



CreatePanel( screen, x, y, width, height, frametype ); // 
Create( screen, x, y, width, height, frametype );
SetControlMouse( mousemethod )
SetControlKeyboard( keymethod )

SaveScreen()

  Active Image opens happen.... in the current display, not above...
  

Update
UpdatePortion()
MoveRel
Size
Move
Close
GetImage
OpenSizedEx 
PutAbove
SetMouseHandler
SetKeyboardHandler
SetResizeHandler
SetLoseFocusHandler
ProcessMessages
GetKeyText
GetMousePosition
GetDisplaySize
OpenSizedAt

-------------------------------------------------------------
// display open/close are top level routines
// open will get the configuration from the configuration file...
// 

PPANEL OpenDisplay();
  results in a panel/container...

CloseDisplay();

SetBackground( PPanel, image, scale/tile );

PPANEL CreatePanel( PPANEL, name, attributes, x, y, width, height );
  A panel is a container region - it has no mouse methods, 
  other than when edit mode is engaged... need Draw modes - cause background


CreateRegion( PPANEL, name, attributes, x, y, width, height );
  // use_existing - if region exists as a name, use those parameters.
  // alpha enabled
  // 

SetShowRegion( true/false ); // hide the region...

SetRegionMouse( mousecallback, ptrszval )
SetRegionDraw( drawcallback, ptrszval )
SetRegionOrder( top/bottom/region below )

-------------------------------------------------------------

This is the linux display driver, it has the additional benefits of being
a FULL screen driver.  This means it opens a single surface, and partitions
that into visible display regions.  No operation on these regions will 
cause them to be able to destroy a covering image.  (Operations need to
not be done directly on the Image itself.  BUT ONLY through this interface
library - which supplies much more clip control.  

This has an input driver. (In windows, this slaves directly from the 
vidlib library - which - one day - we will have to steal its code, since
this is really a subst of features that provides.)

This manages panels and regions.   It provides no border.

PSIlib may be used to draw frames on panels and or regions.  
	PFRAME CreateFrameFromImage( region/panel's image );

	SetFrameMouseInput( PFRAME, SetMouseCallback, psv Panel/Region );
		SetMouseCallback( PTRSZVAL psvRegionPanel, PanelMouseMethod, PFRAME );

	SetFrameKeyInput( PFRAME, SetKeyCallback, psv Panel/Region );
		SetKeyCallback( psv, FrameKeyMethod, frame );

SetFrame_____Input tells the PSI library to use the functions specified to
setup their input requests.  Otherwise, it will use the default methods 
provided in the pActImage.  

Border clipping... GetPanelSurface, GetRegionSurface - have to query
the PSI library if active, to get the respective Frame/ControlSurface.

Perhaps We should just set our interface up so that PSI can use this
directly.   Then anything going through psi goes through this.

Then the application can decide if it wants to use this native, use
the interface, use PSI through this...

Okay then TO the interface!

DisplayLib
	Move the physical images to the screen, handle user inputs.

ImageLib 
 	Clips all operations to the bounds of the ImageFile

DisplayLib
   CLips all operations to the bounds of the Panel.  Loops over the regions
   that it consists of, calling the respective image operation.

PSILib
	Clips all operations to the bounds of the frame/control (minus the border)
	and then draws.  This interfaces directly to the image library.
	Looks like the Image library needs an interface factor.  Except the
	DisplayLib operations would require additional information(?)
		
	Therefore - PSI needs two distinct versions... Native imagefile, native
	displaylib.


ClearImageTo(surface)
	surface->x, surface->y (finds display region), confirmed by the fact that
	Regions that are clipped are linked together.  A union of the rectangle to
	show, and the rectangle showable...
	Surace may be -> a panel/region itself
	              -> a child of a panel/region
	              -> WILL be some child of a panel/region
	if not found, 
		Operation is not done.
	So - the dipslaylib does not need additional information, and may discover
	from the imagefile passed what parts of that image may need to be clipped.


--------------------------------------------------------------




